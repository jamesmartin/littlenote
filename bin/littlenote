#!/usr/bin/env ruby

options = {}

require 'optparse'
OptionParser.new do |opts|
  opts.banner = <<-BANNER
  Usage: littlenote [daterange] [command] [options]

  The most basic usage of littlenote takes no commands or options and simply
  creates a new note:

  littlenote

  These are some common littlenote commands:

  show    Page the content of previous notes through less
  list    List the filenames of previous notes to STDOUT

  Littlenote commands can be constrained using date shortcuts:

  # Pages the past 3 days of notes through less
  littlenote show 3d

  # Lists the previous 1 year of notes on STDOUT
  littlenote list 1y

BANNER

  opts.on("-dDIR", "--directory=DIR", "Directory to write notes into (default: '.')") do |d|
    options[:directory] = d
  end

  opts.on("-v", "--verbose", "Be more explicit about what's happening") do |v|
    options[:verbose] = v
  end
end.parse!

require 'date'
class Logger
  def initialize(out, verbose=false)
    @out = out || STDOUT
    @verbose = verbose
  end

  def verbose?
    !!@verbose
  end

  def log(message)
    @out.puts("#{DateTime.now}: #{message}") if verbose?
  end
end

LOGGER = Logger.new(STDOUT, options[:verbose])
LOGGER.log options

require 'yaml'
class LittleConfig
  attr_reader :config

  def initialize
    @config = YAML.load(File.open(File.join(ENV['HOME'], '.littlenote'), 'r'))
  rescue Errno::ENOENT
    @config = {}
  end
end

module NoteFiles
  def self.within_date_range(date_expression, directory)
    files_matching_regex(
      days_to_show(number_of_days_in(date_expression)),
      directory
    )
  end

  def self.days_in_unit(unit)
    {
      'd' => 1,
      'w' => 7,
      'm' => 31, # vague, but probably good enough for now
      'y' => 365
    }.fetch(unit, 1)
  end

  def self.number_of_days_in(expression)
    return 1 if expression.nil? || expression == ''
    /\A(?<number>\d+)(?<unit>[d|w|m|y])/.match(expression) do |m|
      LOGGER.log "number: #{m[:number]}"
      LOGGER.log "unit: #{m[:unit]}"

      (m[:number] || 1).to_i * days_in_unit(m[:unit])
    end
  end

  def self.days_to_show(number_of_days)
    (0..number_of_days-1).map { |n| (Date.today - n).strftime('%Y-%m-%d') }.join('|')
  end

  def self.files_matching_regex(regex, directory)
    Dir.chdir(directory)
    Dir.glob(File.join("**", "*.md")).select do |f|
      /#{regex}/.match(f)
    end.map { |f| File.join(directory, f) }
  end
end

module Commands

  require 'date'
  class NewNote
    def self.command
      -> (options={}) {
        datetime_stamp = DateTime.now
        filename = File.join(options[:directory], "#{datetime_stamp}.md")

        LOGGER.log("Creating a new note: #{filename}")

        begin
          File.open(filename, 'w+') do |f|
            f << "# #{datetime_stamp}"
          end

          if ENV['EDITOR']
            LOGGER.log("Opening the editor: #{ENV['EDITOR']}")
            exec(ENV['EDITOR'], filename)
          end
        rescue Errno::ENOENT => e
          Logger.new(STDOUT, true)
          logger.log "There was a problem writing to: '#{filename}'"
          logger.log e
        end
      }
    end
  end

  class ShowNotes
    def self.command
      -> (options={}) {
        date_expression = options[:args].first
        LOGGER.log "showing files matching '#{date_expression}' in '#{options[:directory]}'"

        files = NoteFiles.within_date_range(date_expression, options[:directory])

        LOGGER.log "Found entries: #{files}"

        system("cat #{files.join(' ')} | less")
      }
    end
  end

  class ListNotes
    def self.command
      -> (options={}) {
        date_expression = options[:args].first
        LOGGER.log "listing files matching '#{date_expression}' in '#{options[:directory]}'"

        NoteFiles.within_date_range(date_expression, options[:directory]).each do |file|
          STDOUT.puts file
        end
      }
    end
  end

  COMMANDS = {
    # Add callables here to respond to 'commands'
    "show" => ShowNotes.command,
    "list" => ListNotes.command
  }

  def self.lookup(command)
    LOGGER.log "looking up command: '#{command}'"
    command = COMMANDS.fetch(command, NewNote.command)
    LOGGER.log "found command: '#{command}'"
    command
  end
end

config = LittleConfig.new.config
LOGGER.log(config)

if $0 == __FILE__
  Commands.lookup(ARGV.shift).call(
    {
      directory: options[:directory] || config['directory'] || "./",
      args: ARGV
    }
  )
end
