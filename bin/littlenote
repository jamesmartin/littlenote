#!/usr/bin/env ruby

options = {}

require 'optparse'
OptionParser.new do |opts|
  opts.banner = "Usage: littlenote [options]"

  opts.on("-dDIR", "--directory=DIR", "Directory to write notes into (default: '.')") do |d|
    options[:directory] = d
  end

  opts.on("-v", "--verbose", "Be more explicit about what's happening") do |v|
    options[:verbose] = v
  end
end.parse!

require 'date'
class Logger
  def initialize(out, verbose=false)
    @out = out || STDOUT
    @verbose = verbose
  end

  def verbose?
    !!@verbose
  end

  def log(message)
    @out.puts("#{DateTime.now}: #{message}") if verbose?
  end
end

LOGGER = Logger.new(STDOUT, options[:verbose])
LOGGER.log options

require 'yaml'
class LittleConfig
  attr_reader :config

  def initialize
    @config = YAML.load(File.open(File.join(ENV['HOME'], '.littlenote'), 'r'))
  rescue Errno::ENOENT
    @config = {}
  end
end

module Commands

  require 'date'
  class NewNote
    def self.command
      -> (options={}) {
        datetime_stamp = DateTime.now
        filename = File.join(options[:directory], "#{datetime_stamp}.md")

        LOGGER.log("Creating a new note: #{filename}")

        begin
          File.open(filename, 'w+') do |f|
            f << "# #{datetime_stamp}"
          end

          if ENV['EDITOR']
            LOGGER.log("Opening the editor: #{ENV['EDITOR']}")
            exec(ENV['EDITOR'], filename)
          end
        rescue Errno::ENOENT => e
          Logger.new(STDOUT, true)
          logger.log "There was a problem writing to: '#{filename}'"
          logger.log e
        end
      }
    end
  end

  class ShowNotes
    def self.days_in_unit(unit)
      {
        'd' => 1,
        'w' => 7,
        'm' => 31, # vague, but probably good enough for now
        'y' => 365
      }.fetch(unit, 1)
    end

    def self.number_of_days_in(fragment)
      return 1 if fragment.nil? || fragment == ''
      /\A(?<number>\d+)(?<unit>[d|w|m|y])/.match(fragment) do |m|
        LOGGER.log "number: #{m[:number]}"
        LOGGER.log "unit: #{m[:unit]}"

        (m[:number] || 1).to_i * days_in_unit(m[:unit])
      end
    end

    def self.days_to_show(number_of_days)
      (0..number_of_days-1).map { |n| (Date.today - n).strftime('%Y-%m-%d') }.join('|')
    end

    def self.command
      -> (options={}) {
        date_regex = days_to_show(number_of_days_in(options[:args].first))

        LOGGER.log "showing #{date_regex}"

        Dir.chdir(options[:directory])

        files = Dir.glob(File.join("**", "*.md")).select do |f|
          /#{date_regex}/.match(f)
        end.map { |f| File.join(options[:directory], f) }

        LOGGER.log "Found entries: #{files}"

        system("cat #{files.join(' ')} | less")
      }
    end
  end

  COMMANDS = {
    # Add callables here to respond to 'commands'
    "show" => ShowNotes.command
  }

  def self.lookup(command)
    LOGGER.log "looking up command: '#{command}'"
    command = COMMANDS.fetch(command, NewNote.command)
    LOGGER.log "found command: '#{command}'"
    command
  end

end

config = LittleConfig.new.config
LOGGER.log(config)

if $0 == __FILE__
  Commands.lookup(ARGV.shift).call(
    {
      directory: options[:directory] || config['directory'] || "./",
      args: ARGV
    }
  )
end
